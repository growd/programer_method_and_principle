# 程序员术与道：术——编程基本功之进程管理

## 进程概述

文件是程序未启动时候的载体，而进程则是程序实际启动后的载体。如果你一直好奇程序到底是什么，那我可以很负责任的告诉你，程序没有启动的时候是一堆文件，启动后是操作系统中的一个或者多个进程。

如果你听到并发或者并行，那么你一定要了解进程，因为进程是并发或者并行的前提。

如果你好奇计算机上那么多程序是怎么运行的，那么你也一定要了解进程。

程序是指令的集合，而进程则是程序执行的基本单元。程序运行起来成为进程，进而利用处理器资源、内存资源，进行各种I/O操作，从而完成特定任务。

进程，本质意义上说， 是操作系统的调度单位，可以看成是一种操作系统 “资源” 。

进程除了包含程序文件中的指令数据以外，还在内核中有一个数据结构用以存放特定进程的相关属性，以便内核更好地管理和调度进程，从而完成多进程协作的任务。

一个程序可能创建多个进程，通过多个进程的交互完成任务。在linux下，多进程的创建通常是通过fork系统调用来实现。

一个进程，主要包含三个元素：

- 一个可以执行的程序
- 和该进程相关联的全部数据（包括变量，内存空间，缓冲区等等）
- 程序执行的上下文（调用堆栈）

程序可以由多种不同程序语言描述，包括C语言程序、汇编语言程序和最后编译产生的机器指令。



## 进程的基本概念

每一个进程都有一个非负整形表示的唯一进程ID。虽然进程ID总是唯一的，但是可以重用。当一个进程终止，其之前被分配的进程ID就可以再次被使用。

每一个进程都会有状态，进程的状态主要有以下几种：

- 运行

  当一个进程获得了除处理机以外的一切所需资源，一旦得到处理机即可运行，则称此进程处于就绪状态。就绪进程可以按多个优先级来划分队列。例如，当一个进程由于时间片用完而进入就绪状态时，排入低优先级队列；当进程由I／O操作完成而进入就绪状态时，排入高优先级队

- 就绪

  当一个进程在处理机上运行时，则称该进程处于运行状态。处于此状态的进程的数目小于等于处理器的数目，对于单处理机系统，处于运行状态的进程只有一个。在没有其他进程可以执行时（如所有进程都在阻塞状态），通常会自动执行系统的空闲进程

- 阻塞

  也称为等待或睡眠状态，一个进程正在等待某一事件发生（例如请求I/O而等待I/O完成等）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态

进程的基本操作包括：

- 新建
- 休眠
- 停止



## C语言进程基本操作

c语言进程相关操作在unistd.h中定义，使用时需包含该头文件。

fork函数是用于创建一个子进程，该子进程几乎是父进程的副本。

```c
//返回值：成功返回0，表示子进程；
//大于零表示父进程；失败返回 -1，并设置错误代码
pid_t fork(void);
```



如果要子进程去执行另外的程序，需要使用exec函数族。通常exec会放在fork() 函数的子进程部分, 来替代子进程执行啦, 执行成功后子程序就会消失, 但是执行失败的话, 必须用exit()函数来让子进程退出

exec函数族就提供了一个在进程中启动另一个程序执行的方法。它可以根据指定的文件名或目录名找到可执行文件，并用它来取代原调用进程的数据段、代码段和堆栈段，在执行完之后，原调用进程的内容除了进程号外，其他全部被新程序的内容替换了。

exec函数族包含：

- execl()

  ```c
  //execl()用来执行参数path 字符串所代表的文件路径, 
  //接下来的参数代表执行该文件时传递过去的argv(0), argv[1], ...,
  //最后一个参数必须用空指针(NULL)作结束
  //返回值：如果执行成功则函数不会返回, 执行失败则直接返回-1, 失败原因存于errno 中.
  int execl(const char *path, const char *arg, ...);
  ```

  

- execlp()

  ```c
  int execlp(const char *file, const char *arg, ...);
  ```

  

- execle()

  ```c
  int execle(const char *path, const char *arg,..., char * const envp[]);
  ```

  

- execv()

  ```c
  int execv(const char *path, char *const argv[]);
  ```

  

- execvp()

  ```c
  int execvp(const char *file, char *const argv[]);
  ```

  

- execvpe()

  ```c
  int execvpe(const char *file, char *const argv[],char *const envp[]);
  ```

exec函数族装入并运行程序pathname, 并将参数arg0(arg1,arg2,argv[],envp[])传递给子程序, 出错返回-1. 在exec函数族中, 后缀l, v, p, e添加到exec后, 所指定的函数将具有某种操作能力有后缀:

- l: 接受一个以逗号为分割的参数列表, 列表以NULL指针为结束标志.
- v: 接受一个以NULL结尾的字符串数组的指针作为参数.
- p: 表示该次调用执行的程序名, 可以使用PATH环境变量指示的路径, 也就是不用写明程序的完整路径.
- e: 制定环境, 如果无e时, 则表示使用当前程序的环境.

- 进程休眠

  ```c
  //函数说明：sleep()会令目前的进程暂停
  //直到达到参数seconds 所指定的时间, 或是被信号所中断
  unsigned int sleep(unsigned int seconds);
  ```

- C语言进程停止

  先找到进程号，然后用kill命令杀死

  ```shell
  ps -ef |grep program
  kill pid
  ```

## python进程基本操作

- python fork创建子进程(linux)

  python中的os模块封装了常见的系统调用，其中包含fork，通过fork可以轻松的创建子进程

  ```python
  pid = os.fork()
  ```

- 通过process创建

  - Process代表一个进程对象

  - 创建子进程时，只需要在构造函数内传入目标函数以及参数，调用start方法即可

  - join()方法是让主进程等待子进程结束后再执行后续代码

  ```c
  p = Process(target=func(函数名称), args=('test',))
  print('子进程将要执行')
  p.start()
  p.join()
  ```

  

