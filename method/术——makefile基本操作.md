# 程序员术与道：术——makefile基本操作

## makefile是什么

如果你接触过`linux`下的项目，或者接触过C语言的项目，那么你一定听说过makefile。很多有名的开源项目都是用makefile管理的，比如`linux`、`gcc`等等（如果你没有听说过`linux`，那么失礼了）。

makefile用于管理c语言项目，负责项目的编译构建工作,主打依赖管理。经典的开源项目编译三步走如下：

```shell
./configure
make
make install
```





## makefile有什么用

对于C语言来说，或者对于一般的编译型语言来说，程序从源文件到可执行文件都要经历以下步骤：

- 预编译
- 编译
- 汇编
- 链接
- 打包
- 安装

其中最主要的两个过程就是编译和链接，编译就是把每个.c文件编译成目标文件（.o或者.obj）,链接就是把许多个目标文件合并在一起成为一个可执行的文件。这其中其实涉及到了每一个源文件，这些源文件基本都要经历这样一个过程：

```shell
gcc sourcefile1
gcc sourcefile1 sourcefile2 sourcefile3 -o target
```

每一个文件都需要被`gcc`编译一遍，当你的项目足够大时，这份工作是相当庞大的。而且你把源码换到其他地方，还需要继续重复来一遍。这个时候makefile出场了，makefile为你解决了这些重复性的劳动。**让你一次编写，处处运行。**

你一定要记住一句话：

>
>
>在计算机的世界里，如果你在做一件重复的事情，那么你一定要寻找一下或者思考一下，必定有这样的一个软件工具适合你。

makefile为你提供了一些规则，简化了很多的步骤，很大的一个项目只要一个makefile就搞定了，是不是很舒服？

## makefile基本规则

makefile主要使命是依赖管理，因而makefile需要正确处理以下几个问题：

- 依赖是什么
- 目标是什么
- 目标的构建规则是什么

对应以上三个问题，makefile提供以下基本规则：

```makefile
target: depencies
	gcc sourcefile1
	# 构建规则一定要换行加tab，#号是注释
```

恭喜你，你已经学会makefile了，以上就是makefile的精华。（笑，当时我就是这么想的，找工作的时候就为这个出丑了。自吹精通makefile。-..-）

以下是makefile的基本概念：

- 目标

  一个目标（target）就构成一条规则。目标通常是文件名，指明Make命令所要构建的对象。目标可以是一个文件名，也可以是多个文件名，之间用空格分隔。

  除了文件名，目标还可以是某个操作的名字，这称为"伪目标"（phony target）。

  ```makefile
  .PHONY: clean
  clean:
  	rm *.o 
  ```

  

- 依赖

  依赖通常是一组文件或者中间目标，它们用空格隔开。指定了"目标"是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的last-modification时间戳比目标的时间戳新），"目标"就需要重新构建

- 命令

  命令（commands）表示如何更新目标文件，由一行或多行的Shell命令组成。它是构建"目标"的具体指令，它的运行结果通常就是生成目标文件。

  每行命令之前必须有一个tab键。如果想用其他键，可以用内置变量`.RECIPEPREFIX`声明。

- 内置函数

  - **shell**:用来执行shell命令

  - **`wildcard 函数`**：扩展通配符

    ```makefile
    #wildcard把 指定目录 ./ 和 ./sub/ 下的所有后缀是c的文件全部展开
    src=$(wildcard *.c ./sub/*.c)
    ```

  - **`patsubst函数`**：替换通配符

    ```makefile
    #wildcard把 指定目录 ./ 和 ./sub/ 下的所有后缀是c的文件全部展开
    src=$(wildcard *.c ./sub/*.c)
    #patsubst把$(dir)中的变量符合后缀是.c的全部替换成.o
    obj=$(patsubst %.c,%.o,$(dir) )
    ```

    

- 内置变量
  - **$@**:$@指代当前目标，就是Make命令当前构建的那个目标。比如，`make foo`的 $@ 就指代`foo`。
  - **$<**:$< 指代第一个依赖。比如，规则为` t: p1 p2`，那么$< 就指代`p1`。
  - **$?**：$? 指代比目标更新的所有依赖，之间以空格分隔。比如，规则为` t: p1 p2`，其中 `p2` 的时间戳比 t 新，$?就指代`p2`。
  - **$^**：$^ 指代所有依赖，之间以空格分隔。比如，规则为` t: p1 p2`，那么 $^ 就指代 `p1 p2 `。
  - **$\***:$* 指代匹配符 % 匹配的部分， 比如% 匹配 `f1.txt `中的`f1` ，$* 就表示 `f1`。

